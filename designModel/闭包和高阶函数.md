### 作用域

#### 理解作用域：`var a = 2`,引擎干了那些活

- 遇见 var a,编译器会询问当前作用域是否存在该变量，存在，忽略；不存在，在当前作用域下，声明该变量，并命名为 a;
- 运行处理 a=2 时，引擎会询问当前作用域集合是否存在 a 的变量；存在就使用该变量，不存在继续向外层作用域查找该变量；找到了，将 2 赋值给 a，没找到，则抛出异常；
  **总结：** 变量赋值会有两个动作，当前作用域声明该变量，查找变量，找到变量进行赋值；
- LHS 和 RHS 查询：LHS 可以简单说是左侧查询，RHS 右侧查询；LHS 查询，没找到变量会创建变量，RHS 查询，没找到变量抛出异常；

  ```
    function(a){
        var b = a;
        return a+b
    }
    var  c = foo(2);

    LHS:3
    RHS:4
  ```

#### 变量作用域：

- 变量有效范围。

#### 函数作用域：

- 函数可以用来创造函数作用域；函数可以获取外部变量，外部无法获取函数内部变量；如果函数内部没有该变量，函数会根据执行环境创造的作用域链，逐次向外层去寻找该变量。
- 下面代码，也会帮大家理解函数作用域
  ```
        var a = 123;
        var b = 'b1'
        var fn = function () {
            var b = 1;
            var fn1 = function(){
                var c = 'c'
                console.log(c) // c
                console.log(b) // 1
            }
            fn1();
            console.log(c) // c is not defined
        }
        fn()
  ```

#### 变量生存周期

- 在函数内部，函数调用结束就会被销毁；函数外部全局变量，需要手动销毁，不销毁会一直存在内存中，销毁的方案：`var a = null`;

#### 闭包

- 上面将作用域和变量生存周期简单的讲述了一下，接下来将会谈谈闭包，闭包跟这些概念非常紧密。
- 定义：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行；
  实例：不是闭包的例子

  ```
  function foo() { var a = 2;
      function bar() {
          console.log( a ); // 2
      }
      bar();
   }
  foo();
  ```

  实例:闭包效果的实例

  ```
   function foo() {
     var a = 2;
      function bar() {
          console.log( a ); // 2
      }
     return  bar;
   }
  var baz = foo();
  baz();
  ```

  **分析：** 闭包函数外部作用域，可以访问函数内部词法作用域的变量。baz()对该作用域进行引用，这个引用就叫做闭包

- 为了更好的理解闭包，下面在写两个例子
  实例 1：

  ```
   function fo (){
       var a = 2
       function ba(){
           console.log(a)
       }
       bg(ba)
   }
   function bg(fn){
       fn() // 闭包
   }
   fo()
  ```

  实例 2:

  ```
  var bg;
  function fo (){
     var a = 2
     function ba(){
         console.log(a)
     }
    bg = ba;
  }
  function bar(){
     bg() //闭包
  }
   fo();
   bar();
  ```

  **分析:** 总而言之，闭包能将函数内部的作用域，传递到函数外部作用域，进行引用，都会使用闭包。
